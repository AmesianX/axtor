Index: lib/Basic/Targets.cpp
===================================================================
--- lib/Basic/Targets.cpp	(revision 151252)
+++ lib/Basic/Targets.cpp	(working copy)
@@ -923,9 +923,9 @@
 
 namespace {
   static const unsigned PTXAddrSpaceMap[] = {
-    0,    // opencl_global
-    4,    // opencl_local
-    1     // opencl_constant
+    1,    // opencl_global
+    2,    // opencl_local
+    3     // opencl_constant
   };
   class PTXTargetInfo : public TargetInfo {
     static const char * const GCCRegNames[];
Index: lib/Sema/SemaDecl.cpp
===================================================================
--- lib/Sema/SemaDecl.cpp	(revision 151252)
+++ lib/Sema/SemaDecl.cpp	(working copy)
@@ -7046,7 +7046,7 @@
   // duration shall not be qualified by an address-space qualifier."
   // Since all parameters have automatic store duration, they can not have
   // an address space.
-  if (T.getAddressSpace() != 0) {
+  if (!getLangOptions().OpenCL && T.getAddressSpace() != 0) {
     Diag(NameLoc, diag::err_arg_with_address_space);
     New->setInvalidDecl();
   }   
Index: lib/Sema/DeclSpec.cpp
===================================================================
--- lib/Sema/DeclSpec.cpp	(revision 151252)
+++ lib/Sema/DeclSpec.cpp	(working copy)
@@ -428,7 +428,7 @@
     case SCS_private_extern:
     case SCS_auto:
     case SCS_register:
-    case SCS_static:
+    //case SCS_static:
       DiagID   = diag::err_not_opencl_storage_class_specifier;
       PrevSpec = getSpecifierName(SC);
       return true;
Index: lib/Sema/SemaExpr.cpp
===================================================================
--- lib/Sema/SemaExpr.cpp	(revision 151252)
+++ lib/Sema/SemaExpr.cpp	(working copy)
@@ -5637,6 +5637,29 @@
   // Handle the case of an ext vector and scalar.
   if (const ExtVectorType *LV = LHSType->getAs<ExtVectorType>()) {
     QualType EltTy = LV->getElementType();
+
+        // In OpenCL, if one operand is a vector, and the other one is a scalar
+        // the scalar should be converted to the element type used by the vector
+        // and then widened to a vector of the same size. (OpenCL 1.1, section 6.3)
+        if(getLangOptions().OpenCL && RHSType->isScalarType()) {
+          if(EltTy->isIntegerType()) {
+            if(RHSType->isFloatingType())
+              RHS = ImpCastExprToType(RHS.take(), EltTy, CK_FloatingToIntegral);
+            else if(RHSType != EltTy)
+              RHS = ImpCastExprToType(RHS.take(), EltTy, CK_IntegralCast);
+          } else {
+            if(RHSType->isIntegralType(Context))
+              RHS = ImpCastExprToType(RHS.take(), EltTy, CK_IntegralToFloating);
+            else if(RHSType != EltTy)
+              RHS = ImpCastExprToType(RHS.take(), EltTy, CK_FloatingCast);
+          }
+
+          RHS = ImpCastExprToType(RHS.take(), LHSType, CK_VectorSplat);
+
+          if (swapped) std::swap(RHS, LHS);
+          return LHSType;
+        }
+
     if (EltTy->isIntegralType(Context) && RHSType->isIntegralType(Context)) {
       int order = Context.getIntegerTypeOrder(EltTy, RHSType);
       if (order > 0)
